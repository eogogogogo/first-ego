<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    const numbers = [1, 2, 3, 4]
    const fruits = ['Apple', 'Banana', 'Cherry']


    // const a=numbers.map(number=>{
    //   return number<3
    // })
    //위 예제를 더 줄여볼것
    const a = numbers.map(number => number < 3)
    console.log(a) //[true, true, false, false]

    //.filter(): filter메소드의 콜백함수가 요소갯수만큼 실행후 조건을
    // 만족하는 요소를 배열로 반환
    // const b=numbers.filter(number=>{
    //   return number<3
    // })
    //위 예제를 더 줄여볼것
    const b = numbers.filter(number => number < 3)
    console.log(b) //[1,2]
    console.log(numbers) //[1,2,3,4]

    //.find():find메소드의 콜백함수가 요소갯수만큼 실행후 조건을
    // 만족하는 첫번째 요소를 반환
    const c = fruits.find(fruit => {
      //test는 조건참:true, 조건거짓:false
      return /^B/.test(fruit) //정규표현식: /^B/ (대문자B로 시작하는)
    })
    //위 식을 간소화 할것
    console.log(c) //'Banana'
    //.findIndex():findIndex메소드의 콜백함수가 요소갯수만큼 실행후 조건을
    // 만족하는 첫번째 요소의 인덱스를 반환
    const d = fruits.findIndex(fruit => {
      //test는 조건참:true, 조건거짓:false
      return /^C/.test(fruit) //정규표현식: /^C/ (대문자C로 시작하는)
    })
    //위 식을 간호화 할것
    console.log(d) //2 (Cherry index 반환)
    //.includes(): 배열요소에 특정값이 포함되면 true, 아니면 false반환
    const e = numbers.includes(3)
    console.log(e) //true
    const f = fruits.includes('kim')
    console.log(f) //false

    //.slice(startIndex, endIndex): startIndex부터 endIndex 미만까지의
    // 배열을 생성하여 반환(많이 안쓰이는 듯)
    function sliceEx() {
      //인덱스1부터 인덱스3미만
      let newArr = numbers.slice(1, 3);
      console.log(newArr);
      //1번 인덱스 부터 끝까지...
      newArr = numbers.slice(1);
      console.log(newArr);
    }
    sliceEx()
    console.log(numbers)


    //.push(): 배열 가장뒤쪽에 데이터 삽입(아주 중요) 
    //.unshift(): 배열 가장앞쪽에 데이터 삽입(나름 중요)
    //배열 원본 수정됨(주의)
    numbers.push(5)
    console.log(numbers) //[1,2,3,4,5]
    numbers.unshift(0)
    console.log(numbers) //[0,1,2,3,4]
	//.pop() : 배열의 맨뒤쪽 요소 삭제
    numbers.pop();
	 console.log(numbers) //[0,1,2,3]

    //.reverse(): 배열 원본 데이터를 뒤집는다.
    numbers.reverse()
    fruits.reverse()
    console.log(numbers)
    console.log(fruits)

    //.splice(접착)(인덱스, 숫자): 인덱스번호부터 해당하는 데이터를 숫자만큼 삭제 
    const numbers2 = [1, 2, 3, 4]
    const fruits2 = ['Apple', 'Banana', 'Cherry']
    // numbers2.splice(2,1)  //[1,2,4]     
    // numbers2.splice(2,2)  //[1,2] 
    // numbers2.splice(2,0)  //[1,2,3,4]
    // 삽입할 수도 있다.
    //numbers2.splice(2,0,999)  //[1,2,999,3,4], 인덱스2에 999를 삽입하게 됨
    numbers2.splice(2, 1, 999) //[1,2,999,4], 인덱스2부터 1개 삭제후 999를 삽입하게 됨
    numbers2.splice(2, 2, 999) //[1,2,999], 인덱스2부터 2개 삭제후 999를 삽입하게 됨
    console.log(numbers2);
    //문제>fruits2배열 3번째에 'Orange'를 추가할 것.
    fruits2.splice(2, 0, 'Orange')
    console.log(fruits2);
  </script>
</body>

</html>